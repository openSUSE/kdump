#!/bin/bash
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.

. /usr/lib/kdump/kdump-read-config.sh || exit 1

KERNELVERSION=
FORCE=0
QUIET=0
DEBUG=false
DRACUT=/usr/bin/dracut
UPDATE_BOOTLOADER=/sbin/update-bootloader
INITRD_DEFAULT=/var/lib/kdump/initrd
INITRD=$INITRD_DEFAULT

#
# Prints usage.                                                              {{{
function usage()
{
    echo "mkdumprd - Create an initrd for kdump"
    echo ""
    echo "This script uses dracut(8) internally. Options:"
    echo ""
    echo "   -k <kernel>  or"
    echo "   -K <kernel>      Overrides KDUMP_KERNELVER."
    echo "   -I <initrd>      Output file for initrd ($INITRD_DEFAULT by default)"
    echo "   -f               Force regeneration even if the configuration"
    echo "                    did not change."
    echo "   -q               Quiet (don't print status messages)."
    echo "   -d               Output debug information of the initrd build process."
    echo "   -h               Print this help."
}                                                                          # }}}

#
# Quiet message                                                              {{{
function status_message()
{
    local msg=$1

    if (( ! $QUIET )) ; then
        echo ">>> $msg"
    fi
}                                                                          # }}}

#
# Create a new initrd using dracut                                           {{{
function run_dracut()
{
    DRACUT_ARGS="--force --hostonly --no-hostonly-default-device --omit 'plymouth resume usrmount' $@"

    if [ -z "$KERNELVERSION" ]
    then
	KERNELVERSION=$(get_kernel_version "$KERNEL")
    fi

    DRACUT_ARGS="$DRACUT_ARGS --add 'kdump' $INITRD $KERNELVERSION"
    $DEBUG && DRACUT_ARGS="--debug $DRACUT_ARGS"
    echo "Regenerating kdump initrd ..." >&2
    eval "bash -$- $DRACUT $DRACUT_ARGS"
}                                                                          # }}}

#
# Rebuild all initrds                                                        {{{
function build_fadumprd()
{
    # With fadump, this script has no control over which kernel will
    # be booted after a crash, but any installed kernel can be used
    # to save the dump. Consequently, let dracut regenerate initrd
    # for all installed kernels.

    DRACUT_ARGS="--force --regenerate-all"
    $DEBUG && DRACUT_ARGS="--debug $DRACUT_ARGS"
    echo "Regenerating all initrds ..." >&2
    eval "bash -$- $DRACUT $DRACUT_ARGS && type -P $UPDATE_BOOTLOADER &> /dev/null && $UPDATE_BOOTLOADER --refresh"

    # create an empty initrd file, the timestamp will be used to determine
    # if initrds need to be regenerated
    touch $INITRD
}                                                                          # }}}

#
# Build $INITRD with dump capture support using dracut                       {{{
function build_initrd()
{
    get_mount
    if [ "$KDUMP_FADUMP" = "true" ] ; then
        build_fadumprd
    else
        [[ -n "${KDUMP_DRACUT_MOUNT_OPTION}" ]] && KDUMP_DRACUT_MOUNT_OPTION="--mount \"$KDUMP_DRACUT_MOUNT_OPTION\""
        run_dracut --compress \'xz -0 --check=crc32\' ${KDUMP_DRACUT_MOUNT_OPTION}
    fi
}                                                                          # }}}

# exports KDUMP_DRACUT_MOUNT_OPTION for targets mounted by dracut
# For FADUMP builds, this will be propagated to zz-fadumpinit module
function get_mount()
{
	# dracut needs to mount the target directory for the
	# file, nfs and cifs protocols
	MOUNTPOINT="/kdump/mnt"
	case ${KDUMP_PROTO} in 
		file)
			# dereference symlinks, because they might not work in the
			# kdump environment when the directory is mounted elsewhere
			KDUMP_SAVEDIR_REALPATH=$(realpath -m "${KDUMP_SAVEDIR#*://}")
			mkdir -p "${KDUMP_SAVEDIR_REALPATH}"
			read -r SOURCE TARGET FS OPTIONS < <(findmnt -n -v --raw --target "${KDUMP_SAVEDIR_REALPATH}" --output=source,target,fstype,options) ||
				error "Cannot find mount point for ${KDUMP_SAVEDIR#*://}"
			TARGET="${MOUNTPOINT}${TARGET}"
			export KDUMP_DRACUT_MOUNT_OPTION="${SOURCE} ${TARGET} ${FS} ${OPTIONS}"
			;;
		cifs)
                        # split URL into host, directory, user and password parts
			URL="${KDUMP_SAVEDIR#*://}"
                        DIR="/${URL#*/}"    
                        HOST="${URL%%/*}"  
			UPW="${HOST%%@*}"
			HOST="${HOST#*@}"
			USER=
			PW=
			if ! [[ ${UPW} == ${HOST} ]]; then
				USER="${UPW%%:*}"
                        	PW="${UPW#*:}"    
				[[ ${PW} == ${UPW} ]] && PW=""
			fi
			
			export KDUMP_DRACUT_MOUNT_OPTION="//${HOST}${DIR} ${MOUNTPOINT} cifs user=$USER,password=$PW"
			;;
		nfs)
                        # split URL into host, directory, user and password parts
                        URL="${KDUMP_SAVEDIR#*://}"
                        DIR="/${URL#*/}"    
                        HOST="${URL%%/*}"  
			
			export KDUMP_DRACUT_MOUNT_OPTION="${HOST}:${DIR} ${MOUNTPOINT} nfs nolock"
			;;
		*)
			export KDUMP_DRACUT_MOUNT_OPTION=""
			;;
	esac
}

function error()
{
	echo "$1" >&2
	exit 1
}


# Option parsing                                                             {{{
while getopts "hfqk:K:I:d" name ; do
    case $name in
        f)  FORCE=1
            ;;

        h)  usage
            exit 0
            ;;

        q)  QUIET=1
            ;;

        k|K)  KDUMP_KERNELVER="$OPTARG"
            ;;

        I)  INITRD=$OPTARG
            ;;
        
	d)  DEBUG=true
            ;;

        ?)  usage
            exit 1
            ;;
    esac
done
shift $(($OPTIND -1))
                                                                           # }}}


# KDUMP_KERNELVER may be an absolute path name or a kernel version
if [[ ${KDUMP_KERNELVER:0:1} == "/" ]]; then
	# absolute path
	KERNEL=${KDUMP_KERNELVER}
else
	# if a specific version is requested, look for it 
	# in /boot/$IMAGE-$KDUMP_KERNELVER
	# otherwise use the default kernel symlink /boot/$IMAGE
	# IMAGE names are different for different architectures
	
	[[ -n "${KDUMP_KERNELVER}" ]] && KDUMP_KERNELVER="-${KDUMP_KERNELVER}"
	for i in vmlinuz image Image vmlinux; do
		KERNEL="/boot/${i}${KDUMP_KERNELVER}"
		[[ -f $KERNEL ]] && break
	done
fi

if ! [ -f "$KERNEL" ] ; then
    echo "Kernel $KERNEL does not exist."
    exit 1
fi

KERNEL_REALPATH=$(realpath -e "$KERNEL")
if ! [ -f "$KERNEL_REALPATH" ] ; then
    echo "Kernel $KERNEL is an invalid symlink."
    exit 1
fi

# check if we need to regenerate the initrd
KERNEL_CURRENT=$(realpath -qe /var/lib/kdump/kernel)
if (( ! $FORCE )) ; then
    if [ -f "$INITRD" ] && \
            [[ "$KERNEL_REALPATH" == "$KERNEL_CURRENT" ]] && \
            [ /etc/sysconfig/kdump -ot "$INITRD" ] && \
            [ /root/.ssh/id_dsa.pub -ot "$INITRD" ] && \
            [ /root/.ssh/id_dsa -ot "$INITRD" ] && \
            [ /etc/hosts -ot "$INITRD" ] && \
            [ /etc/nsswitch.conf -ot "$INITRD" ]; then
        status_message "Not regenerating kdump initrd. Use mkdumprd -f to force regeneration."
        exit 0
    fi
fi

build_initrd

# if we're rebuilding the default INITRD, update the kernel symlink
# to point to the kernel image the initrd was built for
[[ "$INITRD" == "$INITRD_DEFAULT" ]] && ln -sf "$KERNEL_REALPATH" /var/lib/kdump/kernel

exit $?

# vim: set ts=4 sw=4 et fdm=marker: :collapseFolds=1:
