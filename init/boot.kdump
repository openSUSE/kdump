#!/bin/bash
#
#  Copyright 2005 Red Hat, Inc.
#  Author:  Jeff Moyer <jmoyer@redhat.com>
#  Modifications for SUSE from Chris Mason <mason@suse.com>
#                              Takashi Iwai <tiwai@suse.de>
#                              Bernhard Walle <bwalle@suse.de>
#
#  kdump
#
#  Description:  The kdump init script provides the support necessary for
#                loading a kdump kernel into memory at system bootup time.
#
#
# /etc/init.d/boot.kdump
### BEGIN INIT INFO
# Provides:       boot.kdump
# Required-Start: $local_fs boot.localnet
# Should-Start:
# Should-Stop:
# Required-Stop:  $local_fs boot.localnet
# Default-Start:  B
# Default-Stop:
# Short-Description: kdump boot configuration
# Description:    This script loads the kdump kernel on startup.
### END INIT INFO

. /etc/sysconfig/kdump
. /etc/rc.status

KEXEC=/sbin/kexec
BOOTDIR="/boot"
FADUMP_ENABLED="/sys/kernel/fadump_enabled"
FADUMP_REGISTERED="/sys/kernel/fadump_registered"

#
# Checks if fadump is enabled
#
# Returns: 0 (true) if fadump is enabled
#          1 (false) if fadump is not availabled or disabled
function use_fadump()
{
    test -f $FADUMP_ENABLED && test "$(cat $FADUMP_ENABLED)" = "1"
}

#
# Checks if currently a kdump kernel is loaded.
#
# Returns: 0 (true) if a kdump kernel is loaded,
#          1 (false) if the kdump kernel is not loaded and
#          -1 (false) if the feature is not implemented (too old kernel)
function kdump_kernel_loaded()
{
    if [ -f $FADUMP_REGISTERED ]; then
	if [ "$(cat $FADUMP_REGISTERED)" = "1" ]; then
	    return 0
	else
	    return 1
	fi
    fi

    if [ -r /sys/kernel/kexec_crash_loaded ]; then
        if [ "$(cat /sys/kernel/kexec_crash_loaded)" = "1" ]; then
            return 0
        else
            return 1
        fi
    else
        return -1
    fi
}

#
# Remove an option from the kernel command line
function remove_from_commandline()
{
    local option="$1"

    awk 'BEGIN { ORS="" }
    {
        while(length()) {
            sub(/^[[:space:]]+/,"");
            pstart=match($0,/("[^"]*"?|[^"[:space:]])+/);
            plength=RLENGTH;
            param=substr($0,pstart,plength);
            raw=param;
            gsub(/"/,"",raw);
            if (raw !~ /^('"$option"')(=|$)/)
                print param " ";
            $0=substr($0,pstart+plength);
        }
        print "\n";
    }'
}

#
# Builds the kdump command line from KDUMP_COMMANDLINE.
function build_kdump_commandline()
{
    local commandline="$KDUMP_COMMANDLINE"

    if [ -z "$commandline" ]; then
        commandline=$(
            remove_from_commandline \
                'crashkernel|splash|mem|BOOT_IMAGE|showopts|zfcp\.allow_lun_scan' \
                < /proc/cmdline)
        # Use deadline for saving the memory footprint
        commandline="$commandline elevator=deadline sysrq=yes reset_devices"
        case `uname -i` in
        i?86|x86_64|ia64)
            commandline="$commandline irqpoll maxcpus=${KDUMP_CPUS:-1}"
            ;;
	s390*)
	    commandline="$commandline zfcp.allow_lun_scan=0"
	    ;;
        esac

        # Xen does not include the kernel release in VMCOREINFO_XEN
        # so we have to pass it via the command line
        if [[ "$(uname -r)" =~ -xen$ ]] ; then
            kernelrelease=$(uname -r)
            commandline="$commandline kernelversion=$kernelrelease"
        fi

	if [ -f /sys/firmware/efi/systab ]
	then
		local acpi_addr
		if grep -q '^ACPI20=' /sys/firmware/efi/systab
		then
			acpi_addr=$(awk -F'=' '/^ACPI20=/ {print $2}' /sys/firmware/efi/systab)
		else
			acpi_addr=$(awk -F'=' '/^ACPI=/ {print $2}' /sys/firmware/efi/systab)
		fi
		commandline="$commandline noefi acpi_rsdp=$acpi_addr"
	fi

	case `uname -i` in
	i?86|x86_64)
            commandline=$(echo "$commandline" |
                remove_from_commandline 'unknown_nmi_panic')
            ;;
	esac
    fi

    commandline="$commandline $KDUMP_COMMANDLINE_APPEND"

    echo "$commandline"
}

#
# Builds the kexec options from KEXEC_OPTIONS
# Parameters: 1) kernel
function build_kexec_options()
{
    local kdump_kernel=$1
    local options=$KEXEC_OPTIONS

    # remove `--args-linux' for x86 type kernel files here
    if [ "$(kdumptool identify_kernel -t "$kdump_kernel")" = "x86" ] ; then
        options=$(echo $options | sed -e 's/--args-linux//g')
    fi

    # add --noio on ia64
    if [ "$(uname -i)" = "ia64" ] ; then
        options="$options --noio"
    fi

    echo "$options"
}

# Load kdump using kexec
function load_kdump_kexec()
{
    if [ $(($KDUMP_VERBOSE & 16)) -gt 0 ] ; then
        find_kernel_args="-D"
    fi

    output=$(kdumptool find_kernel $find_kernel_args)
    if [ $? -ne 0 ] ; then
        rc_status -s
        rc_failed 6
        rc_exit
    fi

    kdump_kernel=$(echo "$output" | grep ^Kernel | cut -f 2)
    kdump_initrd=$(echo "$output" | grep ^Initrd | cut -f 2)

    # rebuild the kdump initramfs if necessary, but not at boot
    if [ "$RUNLEVEL" != "B" ]; then
        mkdumprd -K "$kdump_kernel" -I "$kdump_initrd" -q
    fi

    if [ ! -f $kdump_initrd ]; then
        echo -n ": No kdump initial ramdisk found."
        echo "Tried to locate ${kdump_initrd}"
        rc_status -s
        rc_failed 6
        rc_exit
    fi

    local kdump_commandline=$(build_kdump_commandline)
    local kexec_options=$(build_kexec_options "$kdump_kernel")

    KEXEC_CALL="$KEXEC -p $kdump_kernel --append=\"$kdump_commandline\""
    KEXEC_CALL="$KEXEC_CALL --initrd=$kdump_initrd $kexec_options"

    result=$(eval "$KEXEC_CALL" 2>&1)
    rc_check

    # print stderr in any case to show warnings that normally
    # would be supressed (bnc#374185)
    echo "$result"

    if rc_status ; then
        echo 1 > /proc/sys/kernel/panic_on_oops
    fi

    if [ $(($KDUMP_VERBOSE & 4)) -gt 0 ] ; then
        echo "Loading kdump kernel: $KEXEC_CALL"
    fi
    if [ $(($KDUMP_VERBOSE & 1)) -gt 0 ] ; then
        if rc_status ; then
            logger -i -t kdump "Loaded kdump kernel: $KEXEC_CALL, Result: $result"
        else
            logger -i -t kdump \
                "FAILED to load kdump kernel: $KEXEC_CALL, Result: $result"
        fi
    fi

}

# Update fadump configuration
function load_kdump_fadump()
{
    # check if the old configuration is still valid
    boot_opts=$(kdumptool -F /dev/null -C <(kdump-bootloader.pl --get) \
			  dump_config --usage dump --format kernel --nodefault)
    curr_opts=$(kdumptool dump_config --usage dump --format kernel --nodefault)
    if [ "$boot_opts" != "$curr_opts" ]; then
	kdump-bootloader.pl --update "$curr_opts"
    fi

    # The kernel fails with EINVAL if registered already
    # (see bnc#814780)
    if [ "$(cat $FADUMP_REGISTERED)" != "1" ]; then
	echo 1 > $FADUMP_REGISTERED
    fi
    echo 1 > /proc/sys/kernel/panic_on_oops
    rc_reset
}

#
# Load the kdump kerel specified in /etc/sysconfig/kdump
function load_kdump()
{
    local find_kernel_args=
    echo "Loading kdump"

    if use_fadump; then
	load_kdump_fadump
    else
	load_kdump_kexec
    fi

    rc_status -v
}


case "$1" in
  start|restart|force-reload)
        load_kdump
        ;;
  stop)
        if [ "$RUNLEVEL" != "" ]; then
            echo -n "Not unloading kdump during runlevel changes"
            rc_status -s
        else
            kdump_kernel_loaded
            if [ $? -ne 1 ] ; then
                echo -n "Unloading kdump"
		if use_fadump; then
		    # The kernel fails with EINVAL if unregistered already
		    # (see bnc#814780)
		    if [ "$(cat $FADUMP_REGISTERED)" != "0" ]; then
			echo 0 > $FADUMP_REGISTERED
		    fi
		else
                    $KEXEC -p -u
		fi
            fi
            rc_status -v
        fi
        ;;
  status)
        kdump_kernel_loaded
        case $? in
             0)     echo "kdump kernel loaded"
                    rc_status -r -v
                    ;;
             1)     echo "kdump kernel not loaded"
                    rc_failed
                    rc_status -v
                    ;;
            -1)     echo "not implemented"
                    rc_failed 4
                    rc_status -v
                    ;;
        esac
        ;;
  try-restart)
        if kdump_kernel_loaded ; then
            $0 start
        else
            rc_reset
        fi
        rc_status
        ;;
  reload)
        rc_failed 3
        rc_status
        ;;
  *)
        echo $"Usage: $0 {start|stop|status|try-restart|restart|force-reload|reload}"
        exit 1
esac

rc_exit

# vim: set ts=4 sw=4 et:
